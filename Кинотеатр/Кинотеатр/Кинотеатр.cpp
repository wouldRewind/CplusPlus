#include <iostream>
#include <math.h>
using namespace std;

// алгоритм поиска свободных мест: идём по массиву и ищем наибольший подмассив из нулей.
// Затем делим сумму индексов первого и последнего элемента подмассива пополам и округляем в меньшую сторону до целого числа, на это место размещаем школьника 
void cinema(int* arr, int N, int K) { // принимаю массив, его длинну и количество тупоголовых школодронов
    // subRow хранит данные о свободном ряде, где начинается, где заканчивается, какая длина...
    struct
    {
        int head = 0; // где начинается (индекс в массиве)
        int end = 0;  // где заканчивается (индекс в массиве)
        int length = 0; // длинна ряда
        int place = 0; // место, куда мы потом поместим школодрона
    } subRow; // инициализирую структуру на месте

    int maxLength = 0; // максимальная длина найденного подмассива
    // Ищем наибольший свободный подмассив из нулей
    for (int i = 0; i < N; i++)
    {
        if (arr[i] == 0) maxLength++;
        if (i + 1 == N && maxLength > subRow.length)
        {
            // обновляем данные структуры
            subRow.end = i;
            subRow.head = subRow.end - maxLength + 1;
            subRow.length = maxLength;
            subRow.place = ceil((subRow.end + subRow.head) / 2); // округление в большую сторону 
            maxLength = 0;
            break; // на всякий случай выйду из цикла, потому что не известно, что хранится в arr[i+1] в таком случае
        }
        if (arr[i + 1] == 1) // если дальше сидит школьник
        {
            if (maxLength > subRow.length) { // если длина свободного участка превысила максимальный найденный до этого, обновляем данные о самом длинном ряде
                subRow.end = i;
                subRow.head = subRow.end - maxLength + 1;
                subRow.length = maxLength;
                subRow.place = ceil((subRow.end + subRow.head) / 2);
            }
            maxLength = 0;
        }
    }
     // посадить школьника
    arr[subRow.place] = 1; // занятое место помечается единичкой
    K--; // фух, на одного школопета меньше

    // Если мы рассадили не всех школьников, вызываем функцию снова - РЕКУРСИЯ БЛЕ*ТЬ
     if(K > 0) cinema(arr,N,K);
    // // Если рассадили всех, то нужно посмотреть, сколько у последнего школьника соседей слева и справа
     else
     {
         int amount = 0; // число свободных мест(использую дважды - считаю число свободных мест слева и справа)
         int subPlace = subRow.place; // копирую значение в другую переменную, потому что после первого цикла оно потеряется
         // число свободных мест слева
         while (subRow.place > subRow.head)
         {
             amount++;
             subRow.place--;
         }
         cout << "Слева от школьника мест свободно : " << amount << endl;
         amount = 0;
         while (subPlace < subRow.end)
         {
             amount++;
             subPlace++;
         }
         cout << "Справа от школьника мест свободно : " << amount << endl;
     }
    
}
// если мы посчитали последнее свободное место и текущий подмассив длиннее наибольшего, обновляем наибольший подмассив


int main() 
{
    setlocale(LC_ALL, "rus");
    int N, K; // ввод
    cout << "Введите количество мест в кинозале и число школьников(N и K)" << endl;
    cin >> N >> K;
    int* row = new int[N];
    // по умолчанию инициализирую все места в первом ряду пустыми
    for (int i = 0; i < N; i++)
        row[i] = 0;


    // работа алгоритма зашита в функции cinema
    cinema(row, N, K);
    
}
